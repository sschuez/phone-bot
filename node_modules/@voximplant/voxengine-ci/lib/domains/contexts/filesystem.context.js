"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
exports.FileSystemContext = void 0;
const fs_1 = require("fs");
const path_1 = require("path");
const promises_1 = require("fs/promises");
const yaml_1 = require("yaml");
const toml_1 = require("@iarna/toml");
const logMessageGenerator_1 = require("../../utils/logMessageGenerator");
class FileSystemContext {
    constructor(rootDirectoryName, rootMetadataDirectoryName) {
        this.lmg = logMessageGenerator_1.LogMessageGeneratorFactory.getInstance();
        this.init = async () => {
            if (!fs_1.existsSync(this.rootDirectoryPath)) {
                await promises_1.mkdir(this.rootDirectoryPath);
                console.info(this.lmg.generate('INFO__ROOT_DIRECTORY_IS_CREATED', this.rootDirectoryPath));
            }
            if (!fs_1.existsSync(this.rootMetadataDirectoryPath)) {
                await promises_1.mkdir(this.rootMetadataDirectoryPath);
                console.info(this.lmg.generate('INFO__ROOT_DIRECTORY_METADATA_IS_CREATED', this.rootMetadataDirectoryPath));
            }
            console.info(this.lmg.generate('INFO__INIT_SUCCESS', this.constructor.name));
        };
        /**
         * TODO: This is looks like responsibility levels error.
         *  Data transformation can be used on any layers, where we need to transform data from one to another.
         *  So IMHO we need to move the data transformation logic from this method to the something like `helpers` or etc.
         */
        this.transformData = (data, format) => {
            const preparedFormat = format.toLowerCase();
            const availableFormats = this.availableExtensions;
            if (!availableFormats.includes(preparedFormat)) {
                throw new Error(this.lmg.generate('ERR__UNKNOWN_FORMAT', format, availableFormats.toString()));
            }
            if (preparedFormat === 'yaml' || preparedFormat === 'yml') {
                try {
                    console.info(this.lmg.generate('INFO__TRANSFORM_YML_DATA'));
                    return JSON.stringify(yaml_1.parse(data));
                }
                catch (error) {
                    console.error(this.lmg.generate('ERR__CANNOT_TRANSFORM_YML'));
                    throw error;
                }
            }
            if (preparedFormat === 'toml') {
                try {
                    console.info(this.lmg.generate('INFO__TRANSFORM_TOML_DATA'));
                    return JSON.stringify(toml_1.parse(data)['rules']);
                }
                catch (error) {
                    console.error(this.lmg.generate('ERR__CANNOT_TRANSFORM_TOML'));
                    throw error;
                }
            }
            return data.toString();
        };
        // TODO: Remove all 'METADATA' methods and refactor remaining to the second arg
        // somethingToDo(data, isMetadata: boolean = false)
        this.client = {
            resolvePath: (relativePath) => path_1.resolve(this.rootDirectoryPath, relativePath),
            resolveMetadataPath: (relativePath) => path_1.resolve(this.rootMetadataDirectoryPath, relativePath),
            checkExists: (relativePath) => {
                const resolvedPath = this.client.resolvePath(relativePath);
                try {
                    return fs_1.existsSync(resolvedPath);
                }
                catch (error) {
                    console.error(this.lmg.generate('ERR__CHECK_EXISTS_FAILED', this.constructor.name));
                    console.error(error);
                }
            },
            checkMetadataExists: (relativePath) => {
                const resolvedPath = this.client.resolveMetadataPath(relativePath);
                try {
                    return fs_1.existsSync(resolvedPath);
                }
                catch (error) {
                    console.error(this.lmg.generate('ERR__CHECK_METADATA_EXISTS_FAILED', this.constructor.name));
                    console.error(error);
                }
            },
            createDirectory: async (relativePath) => {
                const resolvedPath = this.client.resolvePath(relativePath);
                try {
                    if (!fs_1.existsSync(resolvedPath)) {
                        await promises_1.mkdir(resolvedPath);
                        console.info(this.lmg.generate('INFO__DIRECTORY_IS_CREATED', resolvedPath));
                    }
                }
                catch (error) {
                    console.error(this.lmg.generate('ERR__CREATE_DIRECTORY_FAILED', this.constructor.name));
                    console.error(error);
                }
            },
            createMetadataDirectory: async (relativePath) => {
                const resolvedPath = this.client.resolveMetadataPath(relativePath);
                try {
                    if (!fs_1.existsSync(resolvedPath)) {
                        await promises_1.mkdir(resolvedPath);
                        console.info(this.lmg.generate('INFO__METADATA_DIRECTORY_IS_CREATED', resolvedPath));
                    }
                }
                catch (error) {
                    console.error(this.lmg.generate('ERR__CREATE_DIRECTORY_FAILED', this.constructor.name));
                    console.error(error);
                }
            },
            readDirectory: async (relativePath) => {
                const resolvedPath = this.client.resolvePath(relativePath);
                try {
                    return await promises_1.readdir(resolvedPath);
                }
                catch (error) {
                    console.error(this.lmg.generate('ERR__READ_DIRECTORY_FAILED', this.constructor.name));
                    console.error(error);
                }
            },
            readMetadataDirectory: async (relativePath) => {
                const resolvedPath = this.client.resolveMetadataPath(relativePath);
                return await promises_1.readdir(resolvedPath);
            },
            removeDirectory: async (relativePath) => {
                const resolvedPath = this.client.resolvePath(relativePath);
                try {
                    if (fs_1.existsSync(resolvedPath)) {
                        await promises_1.rm(resolvedPath, {
                            recursive: true,
                            force: true,
                        });
                        console.info(this.lmg.generate('INFO__DIRECTORY_IS_REMOVED', resolvedPath));
                    }
                }
                catch (error) {
                    console.error(this.lmg.generate('ERR__REMOVE_DIRECTORY_FAILED', this.constructor.name));
                    console.error(error);
                }
            },
            removeMetadataDirectory: async (relativePath) => {
                const resolvedPath = this.client.resolveMetadataPath(relativePath);
                try {
                    if (fs_1.existsSync(resolvedPath)) {
                        await promises_1.rm(resolvedPath, {
                            recursive: true,
                            force: true,
                        });
                        console.info(this.lmg.generate('INFO__METADATA_DIRECTORY_IS_REMOVED', resolvedPath));
                    }
                }
                catch (error) {
                    console.error(this.lmg.generate('ERR__REMOVE_METADATA_DIRECTORY_FAILED', this.constructor.name));
                    console.error(error);
                }
            },
            createFile: async (path, name, data, extension = this.availableExtensions[0]) => {
                const joinedPath = path_1.join(path, `${name}.${extension}`);
                const resolvedPath = this.client.resolvePath(joinedPath);
                try {
                    if (fs_1.existsSync(resolvedPath)) {
                        throw new Error(this.lmg.generate('ERR__PATH_FILE_ALREADY_EXISTS', resolvedPath));
                    }
                    await promises_1.writeFile(resolvedPath, data);
                    console.info(this.lmg.generate('INFO__FILE_IS_CREATED', resolvedPath));
                }
                catch (error) {
                    console.error(this.lmg.generate('ERR__CREATE_FILE_FAILED', this.constructor.name));
                    console.error(error);
                }
            },
            createMetadataFile: async (path, name, data) => {
                const extension = this.availableMetadataExtensions[0];
                const joinedPath = path_1.join(path, `${name}.${extension}`);
                const resolvedPath = this.client.resolveMetadataPath(joinedPath);
                try {
                    if (fs_1.existsSync(resolvedPath)) {
                        throw new Error(this.lmg.generate('ERR__PATH_METADATA_FILE_ALREADY_EXISTS', resolvedPath));
                    }
                    await promises_1.writeFile(resolvedPath, data);
                    console.info(this.lmg.generate('INFO__METADATA_FILE_IS_CREATED', resolvedPath));
                }
                catch (error) {
                    console.error(this.lmg.generate('ERR__CREATE_METADATA_FILE_FAILED', this.constructor.name));
                    console.error(error);
                }
            },
            createOrUpdateFile: async (path, name, data, extension = this.availableExtensions[0]) => {
                const joinedPath = path_1.join(path, `${name}.${extension}`);
                const resolvedPath = this.client.resolvePath(joinedPath);
                try {
                    await promises_1.writeFile(resolvedPath, data);
                    console.info(this.lmg.generate('INFO__FILE_IS_CREATED_OR_UPDATED', resolvedPath));
                }
                catch (error) {
                    console.error(this.lmg.generate('ERR__CREATE_OR_UPDATE_FILE_FAILED', this.constructor.name));
                    console.error(error);
                }
            },
            createOrUpdateMetadataFile: async (path, name, data) => {
                const extension = this.availableMetadataExtensions[0];
                const joinedPath = path_1.join(path, `${name}.${extension}`);
                const resolvedPath = this.client.resolveMetadataPath(joinedPath);
                try {
                    await promises_1.writeFile(resolvedPath, data);
                    console.info(this.lmg.generate('INFO__METADATA_FILE_IS_CREATED_OR_UPDATED', resolvedPath));
                }
                catch (error) {
                    console.error(this.lmg.generate('ERR__CREATE_OR_UPDATE_METADATA_FILE_FAILED', this.constructor.name));
                    console.error(error);
                }
            },
            readFile: async (relativePath, availableExtensions = this.availableExtensions) => {
                try {
                    const resolvedFilePathWithoutExtension = this.client.resolvePath(relativePath);
                    const filePathList = availableExtensions.map((extension) => `${resolvedFilePathWithoutExtension}.${extension}`);
                    for (const filePath of filePathList) {
                        const isExists = fs_1.existsSync(filePath);
                        if (isExists) {
                            const data = (await promises_1.readFile(filePath)).toString();
                            const format = path_1.extname(filePath).slice(1);
                            return this.transformData(data, format);
                        }
                    }
                    console.error(this.lmg.generate('ERR__FILE_DOES_NOT_EXIST', resolvedFilePathWithoutExtension));
                }
                catch (error) {
                    console.error(this.lmg.generate('ERR__READ_FILE_FAILED', this.constructor.name));
                    console.error(error);
                }
            },
            readMetadataFile: async (path) => {
                const extension = this.availableMetadataExtensions[0];
                const resolvedPath = this.client.resolveMetadataPath(`${path}.${extension}`);
                try {
                    if (!fs_1.existsSync(resolvedPath)) {
                        console.error(this.lmg.generate('ERR__METADATA_FILE_DOES_NOT_EXIST', resolvedPath));
                        return;
                    }
                    return (await promises_1.readFile(resolvedPath)).toString();
                }
                catch (error) {
                    console.error(this.lmg.generate('ERR__READ_METADATA_FILE_FAILED', this.constructor.name));
                    console.error(error);
                }
            },
            removeFile: async (path, extension = this.availableExtensions[0]) => {
                const resolvedPath = this.client.resolvePath(`${path}.${extension}`);
                try {
                    if (fs_1.existsSync(resolvedPath)) {
                        await promises_1.rm(resolvedPath);
                        console.info(this.lmg.generate('INFO__FILE_IS_REMOVED', resolvedPath));
                    }
                }
                catch (error) {
                    console.error(this.lmg.generate('ERR__REMOVE_FILE_FAILED', this.constructor.name));
                    console.error(error);
                }
            },
            removeMetadataFile: async (path) => {
                const extension = this.availableMetadataExtensions[0];
                const resolvedPath = this.client.resolveMetadataPath(`${path}.${extension}`);
                try {
                    if (fs_1.existsSync(resolvedPath)) {
                        await promises_1.rm(resolvedPath);
                        console.info(this.lmg.generate('INFO__METADATA_FILE_IS_REMOVED', resolvedPath));
                    }
                }
                catch (error) {
                    console.error(this.lmg.generate('ERR__REMOVE_METADATA_FILE_FAILED', this.constructor.name));
                    console.error(error);
                }
            },
        };
        this.rootDirectoryPath = path_1.resolve(rootDirectoryName);
        this.rootMetadataDirectoryPath = path_1.resolve(this.rootDirectoryPath, rootMetadataDirectoryName);
        this.availableExtensions = ['json', 'yml', 'yaml', 'toml', 'ts', 'js'];
        this.availableMetadataExtensions = ['json'];
    }
}
exports.FileSystemContext = FileSystemContext;
