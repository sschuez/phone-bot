"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
exports.VoxRulePlatformRepository = void 0;
const Enums_1 = require("@voximplant/apiclient-nodejs/dist/Enums");
const api_error_response_type_1 = require("../types/api-error-response.type");
const logMessageGenerator_1 = require("../../utils/logMessageGenerator");
class VoxRulePlatformRepository {
    constructor(context) {
        this.context = context;
        this.lmg = logMessageGenerator_1.LogMessageGeneratorFactory.getInstance();
        this.init = () => {
            console.info(this.lmg.generate('INFO__INIT_SUCCESS', this.constructor.name));
        };
        this.downloadApplicationRules = async (applicationId, applicationName) => {
            const response = await this.context.client.Rules.getRules({
                applicationId,
                applicationName,
            });
            if (api_error_response_type_1.isApiErrorResponse(response)) {
                throw new Error(this.lmg.generate('ERR__VOXIMPLANT_API_ERROR', Enums_1.APIErrorCode[response.error.code]));
            }
            if (response.totalCount === 0) {
                console.info(this.lmg.generate('INFO__APP_DOESNT_HAVE_RULES', applicationName));
                return [];
            }
            const { result } = await this.context.client.Rules.getRules({
                applicationId,
                applicationName,
                withScenarios: true,
                count: response.totalCount,
            });
            console.info(this.lmg.generate('INFO__RULES_DOWNLOADED', applicationId.toString(), applicationName));
            return result;
        };
        this.addRule = async (applicationId, ruleName, scenarioId, rulePattern) => {
            const addRuleRequest = {
                applicationId,
                applicationName: '',
                ruleName,
                rulePattern,
                scenarioName: '',
                scenarioId,
            };
            const response = await this.context.client.Rules.addRule(addRuleRequest);
            if (api_error_response_type_1.isApiErrorResponse(response)) {
                throw new Error(this.lmg.generate('ERR__VOXIMPLANT_API_ERROR', Enums_1.APIErrorCode[response.error.code]));
            }
            const { ruleId } = response;
            console.info(this.lmg.generate('INFO__RULE_UPLOADED', ruleId.toString(), ruleName));
            return ruleId;
        };
        this.setRuleInfo = async (rulePattern, ruleId) => {
            const response = await this.context.client.Rules.setRuleInfo({ ruleId, rulePattern });
            if (api_error_response_type_1.isApiErrorResponse(response)) {
                throw new Error(this.lmg.generate('ERR__VOXIMPLANT_API_ERROR', Enums_1.APIErrorCode[response.error.code]));
            }
            console.info(this.lmg.generate('INFO__RULE_UPDATED', ruleId.toString()));
        };
        this.reorderRules = async (rulesIds) => {
            const response = await this.context.client.Rules.reorderRules({
                ruleId: rulesIds,
            });
            if (api_error_response_type_1.isApiErrorResponse(response)) {
                throw new Error(this.lmg.generate('ERR__VOXIMPLANT_API_ERROR', Enums_1.APIErrorCode[response.error.code]));
            }
            console.info(this.lmg.generate('INFO__RULES_REORDERED', rulesIds.toString()));
        };
    }
}
exports.VoxRulePlatformRepository = VoxRulePlatformRepository;
