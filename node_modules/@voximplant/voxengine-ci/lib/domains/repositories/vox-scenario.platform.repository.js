"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
exports.VoxScenarioPlatformRepository = void 0;
const Enums_1 = require("@voximplant/apiclient-nodejs/dist/Enums");
const api_error_response_type_1 = require("../types/api-error-response.type");
const logMessageGenerator_1 = require("../../utils/logMessageGenerator");
class VoxScenarioPlatformRepository {
    constructor(context) {
        this.context = context;
        this.lmg = logMessageGenerator_1.LogMessageGeneratorFactory.getInstance();
        this.init = () => {
            console.info(this.lmg.generate('INFO__INIT_SUCCESS', this.constructor.name));
        };
        this.downloadScenarios = async () => {
            const response = await this.context.client.Scenarios.getScenarios({});
            if (api_error_response_type_1.isApiErrorResponse(response)) {
                throw new Error(this.lmg.generate('ERR__VOXIMPLANT_API_ERROR', Enums_1.APIErrorCode[response.error.code]));
            }
            if (response.totalCount === 0)
                return [];
            const { result } = await this.context.client.Scenarios.getScenarios({
                count: response.totalCount,
            });
            console.info(this.lmg.generate('INFO__SCENARIOS_DOWNLOADED'));
            return result;
        };
        this.downloadScenarioById = async (scenarioId) => {
            const response = await this.context.client.Scenarios.getScenarios({
                scenarioId,
                withScript: true,
            });
            if (api_error_response_type_1.isApiErrorResponse(response)) {
                throw new Error(this.lmg.generate('ERR__VOXIMPLANT_API_ERROR', Enums_1.APIErrorCode[response.error.code]));
            }
            const scenarioInfo = response.result[0];
            if (!scenarioInfo) {
                console.error(this.lmg.generate('ERR__CANNOT_DOWNLOAD_SCENARIO_BY_ID', scenarioId.toString()));
                return;
            }
            console.info(this.lmg.generate('INFO__SCENARIO_BY_ID_DOWNLOADED', scenarioId.toString()));
            return scenarioInfo;
        };
        this.downloadScenarioByName = async (scenarioName) => {
            const response = await this.context.client.Scenarios.getScenarios({
                scenarioName,
                withScript: true,
            });
            if (api_error_response_type_1.isApiErrorResponse(response)) {
                throw new Error(this.lmg.generate('ERR__VOXIMPLANT_API_ERROR', Enums_1.APIErrorCode[response.error.code]));
            }
            const scenarioId = response.result[0]?.scenarioId;
            if (!scenarioId) {
                console.error(this.lmg.generate('ERR__CANNOT_DOWNLOAD_SCENARIO_BY_NAME', scenarioName));
                return;
            }
            const scenarioInfo = await this.downloadScenarioById(scenarioId);
            console.info(this.lmg.generate('INFO__SCENARIO_BY_NAME_DOWNLOADED', scenarioName));
            return scenarioInfo;
        };
        // TODO: Reorder scenarios feature need be implemented
        // await this.context.client.Scenarios.reorderScenarios({...});
        this.addScenario = async (scenarioName, scenarioScript) => {
            try {
                const getScenarioResponse = await this.context.client.Scenarios.getScenarios({
                    scenarioName,
                });
                if (api_error_response_type_1.isApiErrorResponse(getScenarioResponse)) {
                    throw new Error(this.lmg.generate('ERR__VOXIMPLANT_API_ERROR', Enums_1.APIErrorCode[getScenarioResponse.error.code]));
                }
                const scenariosInfo = getScenarioResponse.result;
                const scenarioInfo = scenariosInfo[0];
                if (scenarioInfo) {
                    throw new Error(this.lmg.generate('ERR__SCENARIO_ALREADY_EXISTS', scenarioName));
                }
                const { result, scenarioId } = await this.context.client.Scenarios.addScenario({
                    scenarioName,
                    scenarioScript,
                });
                if (!result) {
                    throw new Error(this.lmg.generate('ERR__CANNOT_ADD_SCENARIO', scenarioName));
                }
                console.info(this.lmg.generate('INFO__SCENARIO_ADDED', scenarioName));
                return scenarioId;
            }
            catch (error) {
                console.error(this.lmg.generate('ERR__ADD_SCENARIO_FAILED', this.constructor.name));
                console.error(error);
            }
        };
        this.updateScenario = async (scenarioId, scenarioName, scenarioScript) => {
            try {
                const response = await this.context.client.Scenarios.setScenarioInfo({
                    scenarioId,
                    requiredScenarioName: scenarioName,
                    scenarioScript,
                });
                if (api_error_response_type_1.isApiErrorResponse(response)) {
                    throw new Error(this.lmg.generate('ERR__VOXIMPLANT_API_ERROR', Enums_1.APIErrorCode[response.error.code]));
                }
                const { result } = response;
                if (!result) {
                    throw new Error(this.lmg.generate('ERR__CANNOT_UPDATE_SCENARIO', scenarioName, scenarioId.toString()));
                }
                console.info(this.lmg.generate('INFO__SCENARIO_UPDATED', scenarioId.toString(), scenarioName));
                return result;
            }
            catch (error) {
                console.error(this.lmg.generate('ERR__UPDATE_SCENARIO_FAILED', this.constructor.name));
                console.error(error);
            }
        };
        this.bindScenarios = async (bindScenarioRequest) => {
            try {
                const response = await this.context.client.Scenarios.bindScenario(bindScenarioRequest);
                const { scenarioId, scenarioName, ruleName } = bindScenarioRequest;
                if (bindScenarioRequest.bind) {
                    console.info(this.lmg.generate('INFO__SCENARIOS_BOUND', scenarioId.toString(), scenarioName.toString(), ruleName));
                }
                if (!bindScenarioRequest.bind) {
                    console.info(this.lmg.generate('INFO__SCENARIOS_DETACHED', scenarioId.toString(), scenarioName.toString(), ruleName));
                }
                return response;
            }
            catch (error) {
                console.error(this.lmg.generate('ERR__BIND_SCENARIO_FAILED', this.constructor.name));
                console.error(error);
            }
        };
    }
}
exports.VoxScenarioPlatformRepository = VoxScenarioPlatformRepository;
