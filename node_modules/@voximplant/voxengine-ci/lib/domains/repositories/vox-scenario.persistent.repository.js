"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
exports.VoxScenarioPersistentRepository = void 0;
const path_1 = require("path");
const abstract_persistent_repository_1 = require("./abstract.persistent.repository");
const vox_scenario_entity_1 = require("../entities/vox-scenario.entity");
class VoxScenarioPersistentRepository extends abstract_persistent_repository_1.AbstractPersistentRepository {
    constructor(context) {
        super(context);
        this.relativeStoragePath = 'scenarios';
        this.srcStorageName = 'src';
        this.relativeSrcStoragePath = path_1.join(this.relativeStoragePath, this.srcStorageName);
        this.distStorageName = 'dist';
        this.relativeDistStoragePath = path_1.join(this.relativeStoragePath, this.distStorageName);
        this.availableExtensions = ['ts', 'js'];
        this.nameSuffix = 'voxengine';
        this.metadataNameSuffix = 'metadata.config';
        this.typingsVoxengineName = 'voxengine.d.ts';
        this.typingsLibsName = 'libs.d.ts';
        this.relativeTypingsPath = 'typings';
        this.relativeTypingsVoxenginePath = path_1.join('..', this.relativeTypingsPath, this.typingsVoxengineName);
        // TODO: Need to think about it...
        this.relativeNodeModulesTypingsVoxenginePath = path_1.join('..', 'node_modules', '@voximplant', 'voxengine-ci', this.relativeTypingsPath, this.typingsVoxengineName);
        this.relativeTypingsLibsPath = path_1.join('..', this.relativeTypingsPath, this.typingsLibsName);
        // TODO: Need to think about it...
        this.relativeNodeModulesTypingsLibsPath = path_1.join('..', 'node_modules', '@voximplant', 'voxengine-ci', this.relativeTypingsPath, this.typingsLibsName);
        this.tsConfigBasename = 'tsconfig.voxengine.temp';
        this.tsConfigExtension = 'json';
        this.tsConfigName = `${this.tsConfigBasename}.${this.tsConfigExtension}`;
        // TODO: Implement specific methods for 'VoxScenarioFileSystemRepository' class
        this.init = async () => {
            await this.context.client.createDirectory(this.relativeStoragePath);
            await this.context.client.createDirectory(this.relativeSrcStoragePath);
            await this.context.client.createDirectory(this.relativeDistStoragePath);
            await this.context.client.createMetadataDirectory(this.relativeStoragePath);
            await this.context.client.createMetadataDirectory(this.relativeSrcStoragePath);
            await this.context.client.createMetadataDirectory(this.relativeDistStoragePath);
            console.info(this.lmg.generate('INFO__INIT_SUCCESS', this.constructor.name));
        };
        this.link = async () => {
            await this.context.client.createDirectory(this.relativeStoragePath);
            await this.linkSrc();
            await this.linkDist();
        };
        this.unlink = async () => {
            await this.context.client.removeDirectory(this.relativeStoragePath);
        };
        this.linkSrc = async () => {
            await this.context.client.createDirectory(this.relativeSrcStoragePath);
        };
        this.unlinkSrc = async () => {
            await this.context.client.removeDirectory(this.relativeSrcStoragePath);
        };
        this.linkDist = async () => {
            await this.context.client.createDirectory(this.relativeDistStoragePath);
        };
        this.unlinkDist = async () => {
            await this.context.client.removeDirectory(this.relativeDistStoragePath);
        };
        this.linkMetadata = async () => {
            await this.context.client.createMetadataDirectory(this.relativeStoragePath);
            await this.linkSrcMetadata();
            await this.linkDistMetadata();
        };
        this.unlinkMetadata = async () => {
            await this.context.client.removeMetadataDirectory(this.relativeStoragePath);
        };
        this.linkSrcMetadata = async () => {
            await this.context.client.createMetadataDirectory(this.relativeSrcStoragePath);
        };
        this.linkDistMetadata = async () => {
            await this.context.client.createMetadataDirectory(this.relativeDistStoragePath);
        };
        this.create = async (voxScenario) => {
            try {
                const { scenarioName, scenarioScript } = voxScenario;
                const fileBasename = `${scenarioName}.${this.nameSuffix}`;
                await this.context.client.createFile(this.relativeSrcStoragePath, fileBasename, scenarioScript, this.availableExtensions[1]);
            }
            catch (error) {
                console.error(this.lmg.generate('ERR__CREATE_FAILED', this.constructor.name));
                console.error(error);
            }
        };
        this.createOrUpdateTsConfig = async (scenarios = []) => {
            try {
                const outDir = this.context.client.resolvePath(this.relativeDistStoragePath);
                const resolvedTypingsVoxenginePath = this.context.client.resolvePath(this.relativeTypingsVoxenginePath);
                const resolvedNodeModulesTypingsVoxenginePath = this.context.client.resolvePath(this.relativeNodeModulesTypingsVoxenginePath);
                const resolvedTypingsLibsPath = this.context.client.resolvePath(this.relativeTypingsLibsPath);
                const resolvedNodeModulesTypingsLibsPath = this.context.client.resolvePath(this.relativeNodeModulesTypingsLibsPath);
                const include = [
                    resolvedTypingsVoxenginePath,
                    resolvedNodeModulesTypingsVoxenginePath,
                    resolvedTypingsLibsPath,
                    resolvedNodeModulesTypingsLibsPath,
                ];
                const exclude = ['node_modules', '**/*.spec.ts'];
                const tsConfig = new vox_scenario_entity_1.VoxScenarioBuilderTsConfig(outDir, include, exclude);
                for (const scenario of scenarios) {
                    const basename = `${scenario}.${this.nameSuffix}`;
                    const joinedPath = path_1.join(this.relativeSrcStoragePath, basename);
                    const pathList = this.availableExtensions.map((extension) => this.context.client.resolvePath(`${joinedPath}.${extension}`));
                    let curScenarioExists = false;
                    for (const path of pathList) {
                        const isExists = this.context.client.checkExists(path);
                        if (isExists) {
                            curScenarioExists = true;
                            tsConfig.include.push(path);
                            console.info(this.lmg.generate('INFO__SCENARIO_ADDED_TO_TSCONFIG', path, this.tsConfigBasename));
                        }
                    }
                    if (!curScenarioExists) {
                        throw new Error(this.lmg.generate('ERR__SCENARIO_DOES_NOT_EXIST', joinedPath));
                    }
                }
                await this.context.client.createOrUpdateFile('.', this.tsConfigBasename, JSON.stringify(tsConfig), this.tsConfigExtension);
            }
            catch (error) {
                console.error(this.lmg.generate('ERR__CREATE_OR_UPDATE_TSCONFIG_FAILED', this.constructor.name));
                throw error;
            }
        };
        this.getTsConfigPath = () => {
            return this.context.client.resolvePath(this.tsConfigName);
        };
        this.removeTsConfig = async () => {
            await this.context.client.removeFile(this.tsConfigBasename);
        };
        this.createMetadata = async (voxScenarioMetadata) => {
            try {
                const { scenarioName } = voxScenarioMetadata;
                const basename = `${scenarioName}.${this.metadataNameSuffix}`;
                await this.context.client.createMetadataFile(this.relativeDistStoragePath, basename, JSON.stringify(voxScenarioMetadata));
            }
            catch (error) {
                console.error(this.lmg.generate('ERR__CREATE_METADATA_FAILED', this.constructor.name));
                console.error(error);
            }
        };
        this.createOrUpdate = async (voxScenario) => {
            try {
                const { scenarioName, scenarioScript } = voxScenario;
                const basename = `${scenarioName}.${this.nameSuffix}`;
                await this.context.client.createOrUpdateFile(this.relativeSrcStoragePath, basename, scenarioScript);
            }
            catch (error) {
                console.error(this.lmg.generate('ERR__CREATE_OR_UPDATE_FAILED', this.constructor.name));
                console.error(error);
            }
        };
        this.createOrUpdateMetadata = async (voxScenarioMetadata) => {
            try {
                const { scenarioName } = voxScenarioMetadata;
                const basename = `${scenarioName}.${this.metadataNameSuffix}`;
                await this.context.client.createOrUpdateMetadataFile(this.relativeDistStoragePath, basename, JSON.stringify(voxScenarioMetadata));
            }
            catch (error) {
                console.error(this.lmg.generate('ERR__CREATE_OR_UPDATE_METADATA_FAILED', this.constructor.name));
                console.error(error);
            }
        };
        this.readSrc = async (scenarioName) => {
            try {
                const joinedPath = path_1.join(this.relativeSrcStoragePath, scenarioName);
                return await this.context.client.readFile(joinedPath);
            }
            catch (error) {
                console.error(this.lmg.generate('ERR__READ_SRC_FAILED', this.constructor.name));
                console.error(error);
            }
        };
        this.readDist = async (scenarioName) => {
            try {
                const joinedPath = path_1.join(this.relativeDistStoragePath, `${scenarioName}.${this.nameSuffix}`);
                return await this.context.client.readFile(joinedPath);
            }
            catch (error) {
                console.error(this.lmg.generate('ERR__READ_DIST_FAILED', this.constructor.name));
                console.error(error);
            }
        };
        this.readSrcMetadata = async (scenarioName) => {
            try {
                const joinedPath = path_1.join(this.relativeSrcStoragePath, `${scenarioName}.${this.metadataNameSuffix}`);
                return await this.context.client.readMetadataFile(joinedPath);
            }
            catch (error) {
                console.error(this.lmg.generate('ERR__READ_SRC_METADATA_FAILED', this.constructor.name));
                console.error(error);
            }
        };
        this.readDistMetadata = async (scenarioName) => {
            try {
                const joinedPath = path_1.join(this.relativeDistStoragePath, `${scenarioName}.${this.metadataNameSuffix}`);
                return await this.context.client.readMetadataFile(joinedPath);
            }
            catch (error) {
                console.error(this.lmg.generate('ERR__READ_DIST_METADATA_FAILED', this.constructor.name));
                console.error(error);
            }
        };
    }
}
exports.VoxScenarioPersistentRepository = VoxScenarioPersistentRepository;
