"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
exports.VoxApplicationService = void 0;
const vox_application_entity_1 = require("../entities/vox-application.entity");
const logMessageGenerator_1 = require("../../utils/logMessageGenerator");
class VoxApplicationService {
    constructor(platformRepository, persistentRepository) {
        this.platformRepository = platformRepository;
        this.persistentRepository = persistentRepository;
        this.lmg = logMessageGenerator_1.LogMessageGeneratorFactory.getInstance();
        this.init = () => {
            console.info(this.lmg.generate('INFO__INIT_SUCCESS', this.constructor.name));
        };
        this.cleanup = async () => {
            await this.persistentRepository.unlink();
            await this.persistentRepository.link();
            await this.persistentRepository.unlinkMetadata();
            await this.persistentRepository.linkMetadata();
        };
        this.checkApplicationsAlreadyExists = async () => {
            try {
                const applications = await this.persistentRepository.readStorage();
                return !!applications?.length;
            }
            catch (error) {
                console.error(error);
            }
        };
        this.downloadApplications = async () => {
            return await this.platformRepository.downloadApplications();
        };
        this.saveApplication = async (rawApplication) => {
            try {
                const voxApplication = new vox_application_entity_1.VoxApplication(rawApplication);
                await this.persistentRepository.createStorage(voxApplication.applicationName);
                await this.persistentRepository.create(voxApplication);
            }
            catch (error) {
                console.error(error);
            }
        };
        this.saveApplicationMetadata = async (rawApplication) => {
            try {
                const voxApplicationMetadata = new vox_application_entity_1.VoxApplicationMetadata(rawApplication);
                await this.persistentRepository.createMetadataStorage(voxApplicationMetadata.applicationName);
                await this.persistentRepository.createMetadata(voxApplicationMetadata);
            }
            catch (error) {
                console.error(error);
            }
        };
        this.readApplicationMetadataStorage = async () => {
            return await this.persistentRepository.readMetadataStorage();
        };
        this.readApplicationMetadata = async (applicationName) => {
            return await this.persistentRepository.readMetadata(applicationName);
        };
        this.getApplicationNameAndId = async (settings) => {
            const { applicationId } = settings;
            const applicationName = await this.getApplicationFullName(settings.applicationName);
            const applications = await this.platformRepository.downloadApplications();
            for (const application of applications) {
                if (applicationId && application.applicationId === applicationId) {
                    return {
                        applicationName: application.applicationName,
                        applicationId,
                    };
                }
                if (!applicationId &&
                    applicationName &&
                    application.applicationName === applicationName) {
                    return {
                        applicationName,
                        applicationId: application.applicationId,
                    };
                }
            }
            if (applicationId) {
                throw new Error(this.lmg.generate('ERR__APP_BY_ID_DOES_NOT_EXIST', applicationId.toString()));
            }
            return { applicationName, applicationId };
        };
        this.getApplicationFullName = async (applicationName) => {
            if (!applicationName)
                return;
            const isFullApplicationName = applicationName.split('.').length > 1;
            if (isFullApplicationName) {
                return applicationName;
            }
            const accountName = await this.platformRepository.getAccountName();
            if (!accountName) {
                throw new Error(this.lmg.generate('ERR__APP_BY_NAME_DOES_NOT_EXIST', applicationName));
            }
            return `${applicationName}.${accountName}.voximplant.com`;
        };
        this.addApplication = async (applicationName) => {
            const applicationData = await this.persistentRepository.read(applicationName);
            if (!applicationData) {
                throw new Error(this.lmg.generate('ERR__APP_BY_NAME_ON_CREATE_DOES_NOT_EXIST', applicationName));
            }
            if (applicationData.applicationName !== applicationName) {
                throw new Error(this.lmg.generate('ERR__APP_NAME_IN_APP_CONFIG_IS_DIFFERENT', applicationData.applicationName, applicationName));
            }
            return await this.platformRepository.addApplication(applicationName);
        };
    }
}
exports.VoxApplicationService = VoxApplicationService;
