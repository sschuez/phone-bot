"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
exports.VoxRuleService = void 0;
const vox_rule_entity_1 = require("../entities/vox-rule.entity");
const logMessageGenerator_1 = require("../../utils/logMessageGenerator");
class VoxRuleService {
    constructor(platformRepository, persistentRepository) {
        this.platformRepository = platformRepository;
        this.persistentRepository = persistentRepository;
        this.lmg = logMessageGenerator_1.LogMessageGeneratorFactory.getInstance();
        this.init = () => {
            console.info(this.lmg.generate('INFO__INIT_SUCCESS', this.constructor.name));
        };
        this.checkRulesAlreadyExists = async () => {
            const rules = await this.persistentRepository.readStorage();
            const rulesMetadata = await this.persistentRepository.readMetadataStorage();
            return !!rules.length && !!rulesMetadata.length;
        };
        this.downloadApplicationRules = async (rawApplication) => {
            const { applicationId, applicationName } = rawApplication;
            return await this.platformRepository.downloadApplicationRules(applicationId, applicationName);
        };
        this.uploadApplicationRule = async (applicationId, ruleName, scenarioId, rulePattern) => this.platformRepository.addRule(applicationId, ruleName, scenarioId, rulePattern);
        this.updateApplicationRule = async (rulePattern, ruleId) => {
            await this.platformRepository.setRuleInfo(rulePattern, ruleId);
        };
        this.saveRules = async (rawApplication, rawRules) => {
            try {
                const { applicationName } = rawApplication;
                await this.persistentRepository.createStorage(applicationName);
                const voxRulesList = rawRules.map((rawRule) => new vox_rule_entity_1.VoxRule(rawRule));
                await this.persistentRepository.create(voxRulesList, applicationName);
            }
            catch (error) {
                console.error(error);
            }
        };
        this.saveRulesMetadata = async (rawApplication, rawRules) => {
            try {
                const { applicationName } = rawApplication;
                await this.persistentRepository.createMetadataStorage(applicationName);
                const voxRulesMetadataList = rawRules.map((rawRule) => new vox_rule_entity_1.VoxRuleMetadata(rawRule));
                await this.persistentRepository.createOrUpdateMetadata(voxRulesMetadataList, applicationName);
            }
            catch (error) {
                console.error(error);
            }
        };
        this.readApplicationRulesByName = async (applicationName) => {
            try {
                const voxRuleList = (await this.persistentRepository.read(applicationName)) || [];
                for (const voxRule of voxRuleList) {
                    if (typeof voxRule.rulePattern !== 'string') {
                        voxRule.rulePattern = '.*';
                    }
                }
                return voxRuleList;
            }
            catch (error) {
                console.error(error);
            }
        };
        this.readApplicationRulesMetadata = async (applicationName) => {
            return ((await this.persistentRepository.readMetadata(applicationName)) || []);
        };
        this.reorderRules = async (rulesFromPlatform, voxRulesList) => {
            if (!rulesFromPlatform.length)
                return;
            const voxRuleListWithId = voxRulesList
                .map((rule) => rulesFromPlatform.find((platformRule) => platformRule.ruleName === rule.ruleName))
                .filter((rule) => rule);
            const newRulesIdOrder = voxRuleListWithId.map(({ ruleId }) => ruleId);
            const existingRulesOrder = rulesFromPlatform.map(({ ruleId }) => ruleId);
            if (newRulesIdOrder.toString() !== existingRulesOrder.toString()) {
                await this.platformRepository.reorderRules(newRulesIdOrder);
            }
        };
    }
}
exports.VoxRuleService = VoxRuleService;
